{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Fluxly","text":"Fluxly <p> Lightweight framework for portable, self-contained DAG-based workflows.      </p> <p> </p> <p>Fluxly is a lightweight framework for building and running directed acyclic graph (DAG)-based workflows.  </p> <p>The entire workflow acts as a self-contained execution endpoint:</p> <ul> <li>Run them locally or via CLI commands, API calls, or environment triggers.</li> <li>Package them in containers for portability.</li> <li>Integrate seamlessly with higher-level orchestrators (Argo, Airflow, Prefect, CI/CD) without extra glue code.</li> </ul> <p>With Fluxly, pipelines are highly structured, enabling safer execution, easier debugging, and better modularity. Workflows can run standalone or as part of a larger system, making Fluxly both lightweight and flexible.</p> <p>Complex workflow</p> <p> <p>Clear representation of workflow DAG with branching and parallel execution.</p> </p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Flexible entrypoints \u2013 workflows can be triggered via CLI, API calls, or environment variables.</li> <li>DAG-based workflows \u2013 define arbitrary connections between ndoes and their dependencies.</li> <li>Highly structured workflows \u2013 strict validation ensures safer pipelines, easier debugging, and predictable behavior.</li> <li>Self-orchestrated nodes \u2013 each node manages its own execution, retries, and dependencies.</li> <li>Lightweight building blocks \u2013 workflows are self-contained units that can run independently in any environment.</li> <li>Extensible by design \u2013 wrap workflows with custom classes to add logging, metrics, or integrations.</li> <li>Local-first development \u2013 debug and run workflows standalone, then scale seamlessly to CI/CD or external orchestrators.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install Fluxly</p> <pre><code>pip install fluxly\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#1-define-workflow-input","title":"1) Define Workflow Input","text":"<p>Define a typed <code>WorkflowInput</code> to specify all inputs your workflow expects. These inputs are agnostic to how the workflow is triggered \u2014 they can come from CLI flags, API requests, or environment variables \u2014 giving you maximum flexibility.</p> <p>WorkflowInput Example</p> <pre><code>from fluxly.workflow import WorkflowInput\n\nclass MyInput(WorkflowInput):\n    message: str = \"world\"\n</code></pre>"},{"location":"#2-make-nodes","title":"2) Make nodes","text":"<p>Implement <code>Node</code> logic in <code>_logic()</code> and type-narrow <code>workflow_input</code> for convenience.</p> <p>Node Example</p> <pre><code>from fluxly.node import Node\n\nclass Echo(Node):\n    @property\n    def workflow_input(self) -&gt; MyInput:\n        return self._workflow_input\n\n    def _logic(self) -&gt; None:\n        self._logger.info(f\"Echo: {self.workflow_input.message}\")\n</code></pre>"},{"location":"#3-build-a-workflow","title":"3) Build a workflow","text":"<p>Create a <code>Workflow</code>, add nodes to it, and wire edges/conditions to express execution order and data dependencies. Workflows orchestrate retries, timeouts, and overall execution.</p> <p>Workflow Example</p> <pre><code>from fluxly.workflow import Workflow\n\ndef build_workflow() -&gt; Workflow:\n    wf = Workflow(name=\"demo\", description=\"Demo flow\", version=\"0.1\")\n\n    # Nodes: demonstrate node-level timeout and retries\n    alpha = Echo(name=\"alpha\", description=\"prints a message\", timeout_seconds=5, max_retries=1, retry_delay_seconds=1)\n    beta = Echo(name=\"beta\", description=\"prints after alpha\")\n    gamma = Echo(name=\"gamma\", description=\"conditional step\")\n\n    # Register nodes to the workflow\n    wf.add_node(alpha)\n    wf.add_node(beta)\n    wf.add_node(gamma)\n\n    # Edges (ordering and conditions)\n    wf.add_edge(alpha, beta)  # run beta after alpha\n    wf.add_conditional_edge(beta, gamma, condition=lambda: True)  # example condition\n\n    return wf\n</code></pre> <p>Edge that runs only if source completed</p> <pre><code># Alternatively, run a node only if its parent completed successfully\nwf.add_edge_if_source_completed(alpha, gamma)\n</code></pre>"},{"location":"#4-expose-your-workflow","title":"4) Expose Your Workflow","text":"<p>Use Fluxly to expose your workflow as a single, consistent entrypoint. Inputs from your <code>WorkflowInput</code> are automatically mapped to CLI flags, API payloads, or environment variables, keeping your interface consistent and type-safe across all triggers.</p> <p>Expose Workflow</p> <pre><code>from fluxly import Fluxly\n\nif __name__ == \"__main__\":\n    app = Fluxly()\n    wf = build_workflow()\n    # register workflow with its input type\n    app.add_endpoint(\"my-workflow\", wf, MyInput)\n    app.run()  # can be triggered via CLI, API, or env vars\n</code></pre> <p>Run it via CLI:</p> <p>Run CLI</p> <pre><code>python main.py my-workflow --message hello\n\n# discover generated flags and help text\npython main.py my-workflow --help\n</code></pre> <p>Trigger via HTTP POST request:</p> <p>Run via API</p> <pre><code>import requests\n\nurl = \"http://localhost:8000/my-workflow/run\"\npayload = {\"message\": \"hello\"}\n\nresponse = requests.post(url, json=payload)\nprint(response.status_code, response.json())\n</code></pre> <p>Trigger via environment variables (with <code>FLUXLY_</code> prefix):</p> <p>Run via Environment Variables</p> <pre><code>export FLUXLY_MESSAGE=\"hello\"\npython main.py my-workflow\n</code></pre>"},{"location":"#generated-entrypoints-cli-and-api","title":"Generated Entrypoints (CLI and API)","text":"<p>Fluxly auto-generates a CLI menu and API routes per registered workflow.</p> <p>CLI Menu</p> <p> <p>CLI commands generated for your workflows.</p> </p> <p>Swagger UI</p> <p> <p>API endpoints for submitting runs and fetching statuses.</p> </p>"},{"location":"#where-to-go-next","title":"Where to go next","text":"<ul> <li>Getting started: project layout, environment, and running the included demo \u2014 Getting started </li> <li>Core concepts: workflows, nodes, execution groups, orchestration controls, and node-to-node communication \u2014 Core concepts </li> </ul>"},{"location":"concepts/","title":"Core concepts","text":"<p>Fluxly revolves around a few central abstractions that let you build typed, maintainable, and DAG-based workflows.</p>"},{"location":"concepts/#workflow","title":"Workflow","text":"<p>A <code>Workflow</code> represents a DAG of nodes, including metadata, inputs, execution history, and orchestration logic.</p> <p>Workflow Responsibilities</p> <ul> <li>Maintain a graph of nodes and their dependencies.</li> <li>Execute nodes respecting DAG constraints.</li> <li>Track executions and statuses.</li> <li>Generate documentation and diagrams if enabled.</li> </ul> <p>Workflow Example</p> <pre><code>from fluxly.workflow import Workflow\n\nwf = Workflow(name=\"demo-workflow\", description=\"Demo workflow\")\n</code></pre>"},{"location":"concepts/#workflowinput","title":"WorkflowInput","text":"<p><code>WorkflowInput</code> defines typed inputs for a workflow.  </p> <p>Typed Inputs</p> <ul> <li>Uses Pydantic for validation.</li> <li>Drives CLI flag generation and API payload validation, including defaults, type hints, and descriptions.</li> <li>Accessible to all nodes via <code>self.workflow_input</code>.</li> </ul> <p>WorkflowInput Example</p> <pre><code>from fluxly.workflow import WorkflowInput\n\nclass MyInput(WorkflowInput):\n    message: str = \"Hello\"\n    repeat: int = 3\n</code></pre>"},{"location":"concepts/#node","title":"Node","text":"<p>A <code>Node</code> represents a single unit of work in a workflow.</p> <p>Node Responsibilities</p> <ul> <li>Encapsulate logic via <code>_logic()</code>.</li> <li>Track execution attempts, status, and errors.</li> <li>Supports <code>timeout_seconds</code>, <code>max_retries</code>, and <code>retry_delay_seconds</code>.</li> <li>Integrates lifecycle hooks (<code>on_start</code>, <code>on_success</code>, <code>on_failure</code>, <code>on_finish</code>).</li> </ul> <p>Node Example</p> <pre><code>from fluxly.node import Node\n\nclass PrintNode(Node):\n    @property\n    def workflow_input(self) -&gt; MyInput:\n        return self._workflow_input\n\n    def _logic(self) -&gt; None:\n        for i in range(self.workflow_input.repeat):\n            self._logger.info(f\"{i+1}: {self.workflow_input.message}\")\n</code></pre>"},{"location":"concepts/#node-to-node-communication","title":"Node-to-Node Communication","text":"<p>Nodes communicate via typed execution classes, either by: - Importing and referencing the upstream node instance after it ran - Using a conditional edge that checks upstream <code>last_execution</code></p> <p>Each node typically lives in its own file; import node classes and create instances in the workflow.</p> <p>producer.py</p> <pre><code>from fluxly.node import Node, NodeExecution, NodeOutput\n\nclass ProducerOutput(NodeOutput):\n    value: int | None = None\n\nclass ProducerExecution(NodeExecution):\n    output: ProducerOutput = ProducerOutput()\n\nclass Producer(Node):\n    def _create_execution(self) -&gt; ProducerExecution:\n        return ProducerExecution()\n\n    def _logic(self) -&gt; None:\n        self.current_execution.output.value = 42\n</code></pre> <p>consumer.py</p> <pre><code>from fluxly.node import Node\n\nfrom producer import Producer\n\nclass Consumer(Node):\n    producer: Producer\n\n    def _logic(self) -&gt; None:\n        value = self.producer.last_execution.output.value\n        self._logger.info(value)\n</code></pre> <p>workflow.py</p> <pre><code>from fluxly.workflow import Workflow\n\nfrom producer import Producer\nfrom consumer import Consumer\n\nwf = Workflow(name=\"demo\")\nproducer = Producer(name=\"producer\")\nconsumer = Consumer(name=\"consumer\", producer=producer)\n\nwf.add_node(producer)\nwf.add_node(consumer)\nwf.add_edge(producer, consumer)\n</code></pre> <p>Conditional edge based on upstream status</p> <pre><code>from fluxly.workflow import Workflow\nfrom fluxly.status import StatusCodes\n\nwf = Workflow(name=\"demo\")\nproducer = Producer(name=\"producer\")\nconsumer = Consumer(name=\"consumer\")\n\nwf.add_node(producer)\nwf.add_node(consumer)\n\n# Run consumer only if producer completed successfully and produced a value\nwf.add_conditional_edge(\n    producer,\n    consumer,\n    condition=lambda: (\n        producer.last_execution.status == StatusCodes.COMPLETED\n        and producer.last_execution.output.value is not None\n    ),\n)\n</code></pre>"},{"location":"concepts/#execution-groups","title":"Execution Groups","text":"<p>Execution groups define sets of nodes, where the workflow is considered successful if at least one group succeeds.  </p> <p>Even after a group succeeds, the workflow continues running until no new runnable nodes remain (i.e., all reachable dependencies are exhausted).</p> <p>Execution Groups</p> <ul> <li>Default: all nodes belong to a single group.  </li> <li>Any group\u2019s success marks the workflow as successful.  </li> <li>Execution continues until all reachable nodes are finished.  </li> <li>Enables partial success tolerance for fault-tolerant workflows.</li> </ul> <p>Execution Group Example</p> <pre><code>workflow.add_execution_group([node_a, node_b])\nworkflow.add_execution_group([node_c])\n</code></pre>"},{"location":"concepts/#edges-and-conditional-edges","title":"Edges and Conditional Edges","text":"<p>Edges define dependencies between nodes. Conditional edges execute only if the condition function evaluates True, which can check the last execution status of a node.</p> <p>Edges Example</p> <pre><code>workflow.add_edge(node_a, node_b)  # node_b runs after node_a\nworkflow.add_conditional_edge(\n    node_b,\n    node_c,\n    condition=lambda: node_b.last_execution.status == StatusCodes.COMPLETED\n)\n</code></pre> <p>Edge that runs only if source completed</p> <pre><code>workflow.add_edge_if_source_completed(node_a, node_b)\n</code></pre>"},{"location":"concepts/#wrapping-extensibility","title":"Wrapping &amp; Extensibility","text":"<p>Workflows and nodes can be wrapped or subclassed to add:</p> <ul> <li>Logging and metrics</li> <li>Policy enforcement</li> <li>Integrations with external services</li> <li>Retry or error-handling strategies</li> </ul> <p>Extensibility Example</p> <pre><code>class LoggingNode(PrintNode):\n    def on_start(self) -&gt; None:\n        self._logger.info(f\"Starting {self.name}\")\n\n    def on_success(self) -&gt; None:\n        self._logger.info(f\"Finished {self.name}\")\n\n    def on_failure(self, error) -&gt; None:\n        self._logger.info(f\"{self.name} failed: {error}\")\n</code></pre> <p>This enables consistent cross-cutting behavior without modifying core business logic.</p>"},{"location":"concepts/#lifecycle-hooks","title":"Lifecycle Hooks","text":"<p>Fluxly nodes provide lifecycle hooks that let you add custom behavior at key points of execution without modifying <code>_logic()</code>.  </p> <p>Available Hooks</p> <ul> <li><code>on_start</code> \u2013 called before <code>_logic()</code> runs.</li> <li><code>on_success</code> \u2013 called after <code>_logic()</code> completes successfully.</li> <li><code>on_failure</code> \u2013 called if <code>_logic()</code> raises an exception.</li> <li><code>on_finish</code> \u2013 always called at the end of execution.</li> </ul> <p>Hooks Example</p> <pre><code>from fluxly.node import Node\n\nfrom my_input import MyInput\n\nclass LoggingNode(Node):\n    @property\n    def workflow_input(self) -&gt; MyInput:\n        return self._workflow_input\n\n    def _logic(self) -&gt; None:\n        self._logger.info(f\"Running logic for {self.name}\")\n\n    def on_start(self) -&gt; None:\n        self._logger.info(f\"Starting node: {self.name}\")\n\n    def on_success(self) -&gt; None:\n        self._logger.info(f\"Node succeeded: {self.name}\")\n\n    def on_failure(self, error) -&gt; None:\n        self._logger.info(f\"Node failed: {self.name} with error {error}\")\n\n    def on_finish(self) -&gt; None:\n        self._logger.info(f\"Finished execution for node: {self.name}\")\n</code></pre>"},{"location":"concepts/#nodeexecution-workflowexecution","title":"NodeExecution &amp; WorkflowExecution","text":"<p>Fluxly allows you to customize the execution structure by overriding how executions, outputs, and metadata are created. This lets you inject custom behavior, logging, or extended data without modifying the core node logic.</p> <p>Default Execution Structure:</p> <ul> <li>NodeExecution wraps:</li> <li><code>metadata</code> \u2192 <code>NodeMetadata</code> (start/end times, computed duration)</li> <li><code>status</code> \u2192 <code>StatusCodes</code> (WAITING, IN_PROGRESS, COMPLETED, FAILED)</li> <li><code>output</code> \u2192 <code>NodeOutput</code> (data produced by <code>_logic()</code>)</li> <li> <p><code>error</code> \u2192 <code>NodeError</code> (if the execution fails)</p> </li> <li> <p>WorkflowExecution aggregates:</p> </li> <li><code>metadata</code> \u2192 <code>WorkflowMetadata</code> (workflow start/end times, execution summary)</li> <li><code>output</code> \u2192 Workflow-level output dictionary</li> <li>Status derived from node executions and execution groups</li> </ul> <p>Custom Execution</p> <p>By overriding <code>_create_execution()</code> on a Node, you can use a custom subclass of <code>NodeExecution</code> that stores extra info (e.g., logs, intermediate metrics).</p> <p>Example:</p> <p>custom_execution.py</p> <pre><code>from pydantic import BaseModel\nfrom fluxly.node import NodeExecution, NodeMetadata\n\n# Custom output for this node\nclass CustomNodeOutput(BaseModel):\n    result_text: str | None = None\n\n# Custom execution with typed metadata and output\nclass CustomNodeExecution(NodeExecution):\n    metadata: NodeMetadata = NodeMetadata()\n    output: CustomNodeOutput = CustomNodeOutput()\n</code></pre> <p>Using Custom Execution:</p> <p>custom_node.py</p> <pre><code>from fluxly.node import Node\n\nimport CustomNodeExecution, CustomNodeOutput\n\nclass CustomNode(Node):\n    @property\n    def current_execution(self) -&gt; CustomNodeExecution:\n        return super().current_execution\n\n    @property\n    def last_execution(self) -&gt; CustomNodeExecution:\n        return super().last_execution\n\n    def _create_execution(self) -&gt; CustomNodeExecution:\n        return CustomNodeExecution()\n\n    def _logic(self) -&gt; None:\n        self.current_execution.output.result_text = f\"processed{suffix}\"\n        self._logger.info(f\"CustomNode produced: {self.current_execution.output.result_text}\")\n</code></pre> <p>Benefits of Custom Execution &amp; Metadata</p> <ul> <li><code>metadata.start_time</code> and <code>metadata.end_time</code> are tracked automatically.</li> <li>Output fields are fully typed for IDE and type-checker support.</li> <li>Custom execution enables per-node outputs and richer metadata.</li> <li>Facilitates advanced workflows with typed inspection and logging.</li> </ul>"},{"location":"demo/","title":"Structured Demo","text":"<p>Fluxly includes a structured demo showcasing how to register and run workflows through the framework.</p> <p>Entry Point</p> <p>Located at: <code>examples/structured_demo/app.py</code></p> <p>Run the demo from the terminal (CLI):</p> <p>Code</p> <pre><code>python examples/structured_demo/app.py structured-demo [--flags]\n</code></pre> <p>Trigger the workflow via an HTTP POST request:</p> <p>API POST Example</p> <pre><code>import requests\n\nurl = \"http://localhost:8000/structured-demo/run\"\npayload = {\"message\": \"Hello, structured demo!\"}\n\nresponse = requests.post(url, json=payload)\nprint(response.status_code, response.json())\n</code></pre> <p>Or trigger it via environment variables (with <code>FLUXLY_</code> prefix to avoid collisions):</p> <p>Environment Variables Example</p> <pre><code>export FLUXLY_MESSAGE=\"Hello, structured demo!\"\npython examples/structured_demo/app.py structured-demo\n</code></pre> <p>This example demonstrates how workflows, nodes, and typed inputs integrate under the framework, whether run via CLI, API, or environment variables.</p>"},{"location":"exceptions/","title":"Typed Exceptions and Consistent Status Codes","text":"<p>Fluxly provides typed exceptions to give precise exit-code and status control. Raise these inside nodes (or workflows) to set both runtime status and process exit code consistently, regardless of whether the workflow is triggered via CLI, API, or environment variables.</p>"},{"location":"exceptions/#built-in-exceptions","title":"Built-in Exceptions","text":"Exception Status Code <code>TimeoutException</code> <code>StatusCodes.TIMED_OUT</code> <code>InfrastructureErrorException</code> <code>StatusCodes.INFRASTRUCTURE_ERROR</code> <code>DataErrorException</code> <code>StatusCodes.DATA_ERROR</code> <code>PrerequisiteFailureException</code> <code>StatusCodes.PREREQUISITE_FAIL</code> <code>APICallFailureException</code> <code>StatusCodes.API_CALL_FAILURE</code> <code>NetworkFailureException</code> <code>StatusCodes.NETWORK_FAILURE</code> <code>DataValidationFailureException</code> <code>StatusCodes.DATA_VALIDATION_FAILURE</code> <code>DependencyUnavailableException</code> <code>StatusCodes.DEPENDENCY_UNAVAILABLE</code>"},{"location":"exceptions/#usage-inside-a-node","title":"Usage Inside a Node","text":"<p>Node Exception Example</p> <pre><code>from fluxly.node import Node\nfrom fluxly.exceptions import DataValidationFailureException\n\nclass Validate(Node):\n    def _is_valid_input(self) -&gt; bool:\n        return False\n\n    def _logic(self) -&gt; None:\n        if not self._is_valid_input():\n            raise DataValidationFailureException(\"Invalid input payload\")\n</code></pre>"},{"location":"exceptions/#custom-exceptions","title":"Custom Exceptions","text":"<p>Define custom exceptions by subclassing <code>WorkflowException</code>. Always set an exit code using a <code>StatusCodes</code> Enum value to ensure consistent behavior across all triggers.</p> <p>Custom Exception Example</p> <pre><code>from enum import Enum\n\nfrom fluxly.exceptions import WorkflowException\nfrom fluxly.status import StatusCodes\n\nclass BusinessRuleViolation(WorkflowException):\n    exit_code: Enum = StatusCodes.DATA_ERROR\n</code></pre> <p>Rules for Custom Exceptions</p> <ul> <li>Exit codes must be validated integers (0\u2013255).  </li> <li>Raising a <code>WorkflowException</code> marks the current node attempt with that status.  </li> <li>Workflow execution propagates the consistent status and exit code downstream, whether running via CLI, API, or environment variables.</li> </ul>"},{"location":"features/","title":"Fluxly \u2014 Flexible, Typed DAG Workflows","text":"<p>Fluxly is a flexible framework for designing, running, and shipping DAG-based workflows with strong typing, lifecycle hooks, and maintainable code structure. It\u2019s built for developers who want predictable, debuggable, and production-ready workflows that can be triggered via CLI, API, or environment variables.</p>"},{"location":"features/#consistent-strongly-typed-interfaces","title":"Consistent, Strongly Typed Interfaces","text":"<p>Each workflow exposes a consistent entrypoint. Inputs from your <code>WorkflowInput</code> class are automatically mapped to CLI flags, API payloads, or environment variables, including type hints, defaults, and descriptions. This eliminates manual parsing and ensures consistent interfaces across scripts and production pipelines.</p> <p>EntryPoint Example</p> <pre><code>from fluxly import Fluxly\nfrom fluxly.workflow import Workflow, WorkflowInput\nfrom fluxly.node import Node\n\nclass MyInput(WorkflowInput):\n    message: str = \"hello\"\n\nclass Echo(Node):\n    @property\n    def workflow_input(self) -&gt; MyInput:\n        return self._workflow_input\n\n    def _logic(self) -&gt; None:\n        self._logger.info(f\"Message: {self.workflow_input.message}\")\n\napp = Fluxly()\napp.add_endpoint(\"echo-msg\", lambda: Workflow(\"echo-demo\"), MyInput)\napp.run()  # CLI, API, or environment triggers\n</code></pre>"},{"location":"features/#modern-python-throughout","title":"Modern Python Throughout","text":"<p>Workflows and nodes are implemented using idiomatic Python classes and type annotations. No DSLs or YAML schemas\u2014use Pydantic for input validation and serialization.</p> <p>Type-safe Node Example</p> <pre><code>class CounterInput(WorkflowInput):\n    count: int = 5\n\nclass Counter(Node):\n    @property\n    def workflow_input(self) -&gt; CounterInput:\n        return self._workflow_input\n\n    def _logic(self) -&gt; None:\n        for i in range(self.workflow_input.count):\n            self._logger.info(f\"Step {i+1}\")\n</code></pre>"},{"location":"features/#node-to-node-communication","title":"Node-to-Node Communication","text":"<p>Nodes communicate via typed execution classes, either by: - Importing and referencing the upstream node instance after it runs. - Using conditional edges based on upstream status.</p> <p>Nodes typically live in their own files; import node classes and create instances in the workflow.</p> <p>producer.py</p> <pre><code>from fluxly.node import Node, NodeExecution, NodeOutput\n\nclass ProducerOutput(NodeOutput):\n    value: int | None = None\n\nclass ProducerExecution(NodeExecution):\n    output: ProducerOutput = ProducerOutput()\n\nclass Producer(Node):\n    def _create_execution(self) -&gt; ProducerExecution:\n        return ProducerExecution()\n\n    def _logic(self) -&gt; None:\n        self.current_execution.output.value = 42\n</code></pre> <p>consumer.py</p> <pre><code>from fluxly.node import Node\nfrom producer import Producer\n\nclass Consumer(Node):\n    producer: Producer\n\n    def _logic(self) -&gt; None:\n        value = self.producer.last_execution.output.value\n        self._logger.info(value)\n</code></pre> <p>workflow.py</p> <pre><code>from fluxly.workflow import Workflow\nfrom producer import Producer\nfrom consumer import Consumer\n\nwf = Workflow(name=\"demo\")\nproducer = Producer(name=\"producer\")\nconsumer = Consumer(name=\"consumer\", producer=producer)\n\nwf.add_node(producer)\nwf.add_node(consumer)\nwf.add_edge(producer, consumer)\n</code></pre> <p>Conditional edge example</p> <pre><code>wf.add_edge_if_source_completed(producer, consumer)\n</code></pre>"},{"location":"features/#dag-orchestration-with-validation-and-retries","title":"DAG Orchestration with Validation and Retries","text":"<p>Workflows are automatically validated as DAGs. Execution respects dependencies and conditional edges.</p> <p>DAG Example</p> <pre><code>wf = Workflow(\"demo\")\n\nnode_a = Echo(name=\"A\", timeout_seconds=5)\nnode_b = Echo(name=\"B\")\nnode_c = Echo(name=\"C\")\n\nwf.add_node(node_a)\nwf.add_node(node_b)\nwf.add_node(node_c)\n\nwf.add_edge(node_a, node_b)\nwf.add_conditional_edge(node_b, node_c, condition=lambda: True)\n</code></pre>"},{"location":"features/#lifecycle-hooks","title":"Lifecycle Hooks","text":"<p>Add cross-cutting behavior without touching business logic. Hooks exist at node and workflow levels:</p> <ul> <li><code>on_start</code> \u2013 before execution  </li> <li><code>on_success</code> \u2013 after success  </li> <li><code>on_failure</code> \u2013 after failure  </li> <li><code>on_finish</code> \u2013 always called</li> </ul> <p>Lifecycle Example</p> <pre><code>class Echo(Node):\n    def on_start(self) -&gt; None:\n        self._logger.info(f\"Starting {self.name}\")\n\n    def on_success(self) -&gt; None:\n        self._logger.info(f\"Finished {self.name}\")\n</code></pre>"},{"location":"features/#typed-exceptions-and-consistent-exit-codes","title":"Typed Exceptions and Consistent Exit Codes","text":"<ul> <li>Raise custom exceptions mapped to <code>StatusCodes</code>.  </li> <li>Entry points (CLI, API, schedulers) receive consistent exit codes.  </li> <li>Ensures predictable CI/CD pipelines.</li> </ul> <p>Exception Example</p> <pre><code>from fluxly.exceptions import WorkflowException\nfrom fluxly.status import StatusCodes\n\nclass MyNode(Node):\n    def _logic(self) -&gt; None:\n        raise WorkflowException(\"Something went wrong\", exit_code=StatusCodes.FAILURE)\n</code></pre>"},{"location":"features/#auto-generated-documentation-and-diagrams","title":"Auto-Generated Documentation and Diagrams","text":"<p>Fluxly can generate Markdown documentation and DAG diagrams automatically. Helps teams review workflow structures and share knowledge.</p> <p>Simple workflow</p> <p> Clear, linear steps for quick tasks.</p> <p>Complex workflow</p> <p> Branching, conditional edges, and parallel paths.</p>"},{"location":"features/#extensible-architecture","title":"Extensible Architecture","text":"<ul> <li>Wrap workflows and nodes to add logging, metrics, policies, integrations.  </li> <li>Define a base layer for shared defaults and configuration.  </li> <li>Scale from local scripts to production pipelines with minimal rewrites.</li> </ul>"},{"location":"features/#tested-and-type-checked","title":"Tested and Type-Checked","text":"<ul> <li>Unit tests cover workflow behavior.  </li> <li>Continuous integration enforces linting, type-checks, and formatting.  </li> <li>Strong typing ensures safe refactors and long-term maintainability.</li> </ul>"},{"location":"getting-started/","title":"Getting Started with Fluxly","text":"<p>Fluxly lets you quickly design, run, and manage DAG-based workflows. Workflows can be triggered via CLI, API, or environment variables, so the same workflow works in any context. This guide walks you through creating your first workflow, adding nodes, handling inputs, and executing it through your chosen entrypoint.</p>"},{"location":"getting-started/#1-install-fluxly","title":"1. Install Fluxly","text":"<p>Install via pip:</p> <p>Install via pip</p> <pre><code>pip install fluxly\n</code></pre> <p>Or clone the repository for development:</p> <p>Clone for development</p> <pre><code>git clone https://github.com/your-repo/fluxly.git\ncd fluxly\npip install -e .\n</code></pre>"},{"location":"getting-started/#2-define-a-workflow-input","title":"2. Define a Workflow Input","text":"<p>Workflows use typed inputs with Pydantic for validation. These inputs can be provided via CLI flags, API payloads, or environment variables, keeping your workflows flexible and consistent. Annotate fields with descriptions and constraints to improve validation and automatically generate help text for any entrypoint.</p> <p>Workflow Input Example</p> <pre><code>from typing import Annotated\n\nfrom pydantic import Field\nfrom fluxly.workflow import WorkflowInput\n\nclass MyWorkflowInput(WorkflowInput):\n    message: Annotated[str, Field(min_length=1, max_length=100, description=\"Message to print\")] = \"Hello, Fluxly!\"\n    repeat: Annotated[int, Field(ge=1, le=10, description=\"How many times to repeat\")] = 3\n</code></pre>"},{"location":"getting-started/#3-create-nodes","title":"3. Create Nodes","text":"<p>Nodes encapsulate single units of work. Each node receives the workflow input and communicates results via typed outputs, avoiding ad-hoc dictionaries or positional references.</p> <p>Node Example</p> <pre><code>from fluxly.node import Node\n\nclass PrintNode(Node):\n    @property\n    def workflow_input(self) -&gt; MyWorkflowInput:\n        return self._workflow_input\n\n    def _logic(self) -&gt; None:\n        for i in range(self.workflow_input.repeat):\n            self._logger.info(f\"{i+1}: {self.workflow_input.message}\")\n</code></pre>"},{"location":"getting-started/#4-assemble-a-workflow","title":"4. Assemble a Workflow","text":"<p>Create a workflow, add nodes, and define their dependencies.</p> <p>Assemble Workflow</p> <pre><code>from fluxly.workflow import Workflow\n\nworkflow = Workflow(name=\"demo-workflow\")\n\n# Nodes\nnode_a = PrintNode(name=\"PrintMessage\")\n\n# Add nodes\nworkflow.add_node(node_a)\n\n# Optionally, add edges if multiple nodes exist\n# workflow.add_edge(node_a, node_b)\n# workflow.add_edge_if_source_completed(node_a, node_b)  # run node_b only if node_a completed\n</code></pre>"},{"location":"getting-started/#5-execute-the-workflow","title":"5. Execute the Workflow","text":"<p>Fluxly exposes your workflow as a entrypoint that can be triggered via CLI, API, or environment variables. Your <code>WorkflowInput</code> is the single source of truth for both CLI flags and API payload validation.</p> <p>Execute Workflow</p> <pre><code>from fluxly import Fluxly\n\napp = Fluxly()\napp.add_endpoint(\"run-demo\", workflow, MyWorkflowInput)\napp.run()  # auto: CLI if args present, otherwise API server\n</code></pre> <p>Run from the terminal (CLI example):</p> <p>Run CLI</p> <pre><code>python your_script.py run-demo --message \"Hi there!\" --repeat 5\n</code></pre> <p>Trigger via HTTP POST request:</p> <p>Run via API</p> <pre><code>import requests\n\nurl = \"http://localhost:8000/run-demo/run\"\npayload = {\"message\": \"Hello!\"}\n\nresponse = requests.post(url, json=payload)\nprint(response.status_code, response.json())\n</code></pre> <p>Trigger via environment variables (with <code>FLUXLY_</code> prefix to avoid collisions):</p> <p>Run via Environment Variables</p> <pre><code>export FLUXLY_MESSAGE=\"Hello!\"\nexport FLUXLY_REPEAT=5\npython your_script.py run-demo\n</code></pre>"},{"location":"getting-started/#choose-your-entrypoint-explicitly","title":"Choose your entrypoint explicitly","text":"<p>Use one of the following based on your deployment context:</p> <ul> <li><code>app.run()</code> \u2014 auto-selects: runs CLI when arguments are provided, otherwise starts the API server.</li> <li><code>app.run_cli()</code> \u2014 force CLI mode.</li> <li><code>app.run_api()</code> \u2014 force API server.</li> </ul> <p>Explicit run modes</p> <pre><code>from fluxly import Fluxly\n\napp = Fluxly()\napp.add_endpoint(\"run-demo\", workflow, MyWorkflowInput)\n\n# Force CLI\n# app.run_cli()\n\n# Force API\n# app.run_api()\n</code></pre>"},{"location":"getting-started/#configure-the-fastapiuvicorn-server","title":"Configure the FastAPI/Uvicorn server","text":"<p>You can pass FastAPI and Uvicorn settings via <code>ApiConfig</code> and <code>app.configure_api()</code>.</p> <p>API configuration</p> <pre><code>from fluxly import Fluxly\nfrom fluxly.api.server import ApiConfig\n\napp = Fluxly()\napp.add_endpoint(\"run-demo\", workflow, MyWorkflowInput)\n\napp.configure_api(\n    ApiConfig(\n        host=\"0.0.0.0\",\n        port=9000,\n        log_level=\"info\",\n        fastapi_kwargs={\n            \"docs_url\": \"/docs\",\n            \"openapi_url\": \"/openapi.json\",\n        },\n        uvicorn_kwargs={\n            \"reload\": True,\n            # any other uvicorn.run kwargs\n        },\n    )\n)\n\napp.run_api()\n</code></pre>"},{"location":"getting-started/#6-handle-lifecycle-hooks","title":"6. Handle Lifecycle Hooks","text":"<p>Extend nodes with hooks for logging, metrics, cleanup, or notifications. Hooks exist for both nodes and workflows:</p> <ul> <li><code>on_start</code> \u2013 before execution  </li> <li><code>on_success</code> \u2013 after successful completion  </li> <li><code>on_failure</code> \u2013 after failure  </li> <li><code>on_finish</code> \u2013 always called</li> </ul> <p>Lifecycle Hooks Example</p> <pre><code>class LoggingNode(PrintNode):\n    def on_start(self) -&gt; None:\n        self._logger.info(f\"Starting node: {self.name}\")\n\n    def on_success(self) -&gt; None:\n        self._logger.info(f\"Finished node: {self.name}\")\n\n    def on_failure(self, error) -&gt; None:\n        self._logger.info(f\"Node {self.name} failed: {error}\")\n</code></pre>"},{"location":"getting-started/#7-enable-auto-generated-documentation","title":"7. Enable Auto-Generated Documentation","text":"<p>Fluxly can automatically generate Markdown documentation and DAG diagrams. You can configure this either:</p> <ul> <li>Programmatically: set defaults in <code>workflow.inputs</code>.</li> <li>At runtime: provide flags, API payloads, or environment variables; all map to <code>WorkflowInput</code> fields.</li> </ul> <p>Programmatic defaults (set once)</p> <pre><code># Set default documentation behavior on the workflow template\nworkflow.inputs = MyWorkflowInput(\n    auto_generate_md=True,\n    md_file_path=\"workflow_doc.md\",\n    diagram_file_path=\"workflow_diagram.png\",\n)\n</code></pre> <p>Run from the terminal (CLI example):</p> <p>Override via CLI flags</p> <pre><code>python your_script.py run-demo \\\n  --auto-generate-md \\\n  --md-file-path workflow_doc.md \\\n  --diagram-file-path workflow_diagram.png\n</code></pre> <p>Trigger via API POST request:</p> <p>Override via API</p> <pre><code>import requests\n\nurl = \"http://localhost:8000/run-demo/run\"\npayload = {\n    \"auto_generate_md\": True,\n    \"md_file_path\": \"workflow_doc.md\",\n    \"diagram_file_path\": \"workflow_diagram.png\",\n}\n\nresponse = requests.post(url, json=payload)\nprint(response.status_code, response.json())\n</code></pre> <p>Trigger via environment variables (with <code>FLUXLY_</code> prefix):</p> <p>Override via Environment Variables</p> <pre><code>export FLUXLY_AUTO_GENERATE_MD=1\nexport FLUXLY_MD_FILE_PATH=\"workflow_doc.md\"\nexport FLUXLY_DIAGRAM_FILE_PATH=\"workflow_diagram.png\"\npython your_script.py run-demo\n</code></pre> <p>Note</p> <p>At the end of execution, Fluxly outputs a readable summary and a diagram of the workflow. This is useful for reviews, knowledge sharing, and onboarding new developers.</p>"},{"location":"getting-started/#8-next-steps","title":"8. Next Steps","text":"<ul> <li>Add conditional edges and parallel execution groups.</li> <li>Explore typed exceptions for reliable error handling.</li> <li>Integrate with logging, metrics, or CI/CD pipelines.</li> <li>Write unit tests for workflows and nodes to ensure predictable behavior.</li> </ul> <p>Note</p> <p>Once you are comfortable with the basics, you can start building production-ready pipelines using Fluxly, scaling from local scripts to distributed workflows.</p>"},{"location":"input-flags/","title":"Input flags","text":""},{"location":"input-flags/#workflowinput-schema-for-cli-flags-and-api-payloads","title":"WorkflowInput schema for CLI flags and API payloads","text":"<p><code>WorkflowInput</code> is the single source of truth for your workflow\u2019s inputs. Its fields are used to both auto-generate CLI flags and validate API payloads, and also power generated documentation. You can control how each field is exposed or presented using <code>json_schema_extra</code>.</p> <p>Supported Extras per Field</p> <ul> <li><code>exclude_from_cli</code>: if <code>True</code>, the field is omitted from the CLI.  </li> <li><code>convert_underscores</code>: if <code>False</code>, field name underscores are preserved (default converts underscores to dashes).  </li> <li><code>exclude_from_documentation</code>: if <code>True</code>, the field is omitted from generated docs.</li> </ul> <p>Note</p> <p>These options affect CLI flag generation and docs. API payload validation still follows the <code>WorkflowInput</code> schema.</p> <p>WorkflowInput Example</p> <pre><code>from typing import Annotated\n\nfrom pydantic import Field\nfrom fluxly.workflow import WorkflowInput\n\nclass MyInput(WorkflowInput):\n    secret_token: Annotated[str | None, Field(\n        default=None,\n        description=\"Authentication token\",\n        json_schema_extra={\"exclude_from_cli\": True, \"exclude_from_documentation\": True},\n    )]\n\n    cool_flag: Annotated[bool, Field(\n        default=False,\n        description=\"Enable cool stuff\",\n        json_schema_extra={\"convert_underscores\": True},\n    )]\n</code></pre>"},{"location":"people/","title":"Maintainers","text":"<ul> <li>Shahar Band \u2014 creator and maintainer</li> </ul> <p>Contributions are welcome via pull requests on the repository.</p>"},{"location":"resources/","title":"Resources","text":"<p>More about Fluxly:</p> <ul> <li>Repository: GitHub </li> <li>PyPI: fluxly </li> <li>Report Issues: GitHub Issues </li> </ul> <p>Article Coming Soon</p> <p>A detailed article explaining Fluxly concepts and usage will be published shortly.</p>"}]}
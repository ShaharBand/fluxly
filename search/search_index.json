{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"FluxCLI <p>Lightweight, CLI-first framework for building DAG-based workflows</p> <p> </p> <p>FluxCLI lets you build and run structured, DAG-based workflows where each workflow becomes a CLI command. It's local-first for easy debugging and portable for orchestration.</p> <p>Complex workflow</p> <p> <p>Clear representation of workflow DAG with branching and parallel execution.</p> </p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>CLI-based actions \u2013 every node has a clear interface for inputs and outputs.</li> <li>DAG-based workflows \u2013 define arbitrary connections between tasks and their dependencies.</li> <li>Highly structured workflows \u2013 strict validation ensures safer pipelines, easier debugging, and predictable behavior.</li> <li>Self-orchestrated nodes \u2013 each node manages its own execution, retries, and dependencies.</li> <li>Lightweight building blocks \u2013 workflows are small, self-contained units that can each run in their own environment.</li> <li>Extensible by design \u2013 wrap workflows with your own classes to add logging, metrics, or integrations.</li> <li>Local-first development \u2013 debug and run workflows as simple CLIs, then scale them seamlessly to CI/CD or external orchestrators.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install FluxCLI</p> <pre><code>pip install fluxcli\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#1-define-workflow-input","title":"1) Define workflow input","text":"<p>Create a typed <code>WorkflowInput</code>. These fields become CLI flags automatically.</p> <p>WorkflowInput Example</p> <pre><code>from fluxcli.workflow import WorkflowInput\n\nclass MyInput(WorkflowInput):\n    message: str = \"world\"\n</code></pre>"},{"location":"#2-make-nodes","title":"2) Make nodes","text":"<p>Implement <code>Node</code> logic in <code>_logic()</code> and type-narrow <code>workflow_input</code> for convenience.</p> <p>Node Example</p> <pre><code>from fluxcli.node import Node\n\nclass Echo(Node):\n    @property\n    def workflow_input(self) -&gt; MyInput:\n        return self._workflow_input\n\n    def _logic(self) -&gt; None:\n        self._logger.info(f\"Echo: {self.workflow_input.message}\")\n</code></pre>"},{"location":"#3-build-a-workflow","title":"3) Build a workflow","text":"<p>Create a <code>Workflow</code>, add nodes to it, and wire edges/conditions to express execution order and data dependencies. Workflows orchestrate retries, timeouts, and overall execution.</p> <p>Workflow Example</p> <pre><code>from fluxcli.workflow import Workflow\n\ndef build_workflow() -&gt; Workflow:\n    wf = Workflow(name=\"demo\", description=\"Demo flow\", version=\"0.1\")\n\n    # Nodes: demonstrate node-level timeout and retries\n    alpha = Echo(name=\"alpha\", description=\"prints a message\", timeout_seconds=5, max_retries=1, retry_delay_seconds=1)\n    beta = Echo(name=\"beta\", description=\"prints after alpha\")\n    gamma = Echo(name=\"gamma\", description=\"conditional step\")\n\n    # Register nodes to the workflow\n    wf.add_node(alpha)\n    wf.add_node(beta)\n    wf.add_node(gamma)\n\n    # Edges (ordering and conditions)\n    wf.add_edge(alpha, beta)  # run beta after alpha\n    wf.add_conditional_edge(beta, gamma, condition=lambda: True)  # example condition\n\n    return wf\n</code></pre> <p>Edge that runs only if source completed</p> <pre><code># Alternatively, run a node only if its parent completed successfully\nwf.add_edge_if_source_completed(alpha, gamma)\n</code></pre>"},{"location":"#4-wire-into-a-cli","title":"4) Wire into a CLI","text":"<p>Use <code>FluxCLI</code> to expose your workflow as a single command. CLI flags are auto-generated from your <code>WorkflowInput</code> fields (with types and defaults), so your interface stays consistent with your code.</p> <p>Expose Workflow via CLI</p> <pre><code>from fluxcli import FluxCLI\n\nif __name__ == \"__main__\":\n    cli = FluxCLI()\n    wf = build_workflow()\n    cli.add_command(\"my-workflow\", wf, MyInput)\n    cli.run()\n</code></pre> <p>Run it:</p> <p>Run the CLI</p> <pre><code>python cli.py my-workflow --message hello\n\n# discover generated flags and help text\npython cli.py my-workflow --help\n</code></pre>"},{"location":"#where-to-go-next","title":"Where to go next","text":"<ul> <li>Getting started: project layout, environment, and running the included demo \u2014 Getting started </li> <li>Core concepts: workflows, nodes, execution groups, orchestration controls, and node-to-node communication \u2014 Core concepts </li> </ul>"},{"location":"cli-flags/","title":"CLI flags","text":""},{"location":"cli-flags/#workflowinput-flags-for-cli-and-documentation","title":"WorkflowInput Flags for CLI and Documentation","text":"<p>Fields in a <code>WorkflowInput</code> are used to auto-generate CLI flags and documentation. You can control how each field is exposed or presented using <code>json_schema_extra</code>.</p> <p>Supported Extras per Field</p> <ul> <li><code>exclude_from_cli</code>: if <code>True</code>, the field is omitted from the CLI.  </li> <li><code>convert_underscores</code>: if <code>False</code>, field name underscores are preserved (default converts underscores to dashes).  </li> <li><code>exclude_from_documentation</code>: if <code>True</code>, the field is omitted from generated docs.</li> </ul> <p>WorkflowInput Example</p> <pre><code>from typing import Annotated\n\nfrom pydantic import Field\nfrom fluxcli.workflow import WorkflowInput\n\nclass MyInput(WorkflowInput):\n    secret_token: Annotated[str | None, Field(\n        default=None,\n        description=\"Authentication token\",\n        json_schema_extra={\"exclude_from_cli\": True, \"exclude_from_documentation\": True},\n    )]\n\n    cool_flag: Annotated[bool, Field(\n        default=False,\n        description=\"Enable cool stuff\",\n        json_schema_extra={\"convert_underscores\": True},\n    )]\n</code></pre>"},{"location":"concepts/","title":"Core concepts","text":"<p>FluxCLI revolves around a few central abstractions that let you build typed, maintainable, and DAG-based workflows.</p>"},{"location":"concepts/#workflow","title":"Workflow","text":"<p>A <code>Workflow</code> represents a DAG of nodes, including metadata, inputs, execution history, and orchestration logic.</p> <p>Workflow Responsibilities</p> <ul> <li>Maintain a graph of nodes and their dependencies.</li> <li>Execute nodes respecting DAG constraints.</li> <li>Track executions and statuses.</li> <li>Generate documentation and diagrams if enabled.</li> </ul> <p>Workflow Example</p> <pre><code>from fluxcli.workflow import Workflow\n\nwf = Workflow(name=\"demo-workflow\", description=\"Demo workflow\")\n</code></pre>"},{"location":"concepts/#workflowinput","title":"WorkflowInput","text":"<p><code>WorkflowInput</code> defines typed inputs for a workflow.  </p> <p>Typed Inputs</p> <ul> <li>Uses Pydantic for validation.</li> <li>Drives CLI auto-generation, including flags, defaults, and type hints.</li> <li>Accessible to all nodes via <code>self.workflow_input</code>.</li> </ul> <p>WorkflowInput Example</p> <pre><code>from fluxcli.workflow import WorkflowInput\n\nclass MyInput(WorkflowInput):\n    message: str = \"Hello\"\n    repeat: int = 3\n</code></pre>"},{"location":"concepts/#node","title":"Node","text":"<p>A <code>Node</code> represents a single unit of work in a workflow.</p> <p>Node Responsibilities</p> <ul> <li>Encapsulate logic via <code>_logic()</code>.</li> <li>Track execution attempts, status, and errors.</li> <li>Supports <code>timeout_seconds</code>, <code>max_retries</code>, and <code>retry_delay_seconds</code>.</li> <li>Integrates lifecycle hooks (<code>on_start</code>, <code>on_success</code>, <code>on_failure</code>, <code>on_finish</code>).</li> </ul> <p>Node Example</p> <pre><code>from fluxcli.node import Node\n\nclass PrintNode(Node):\n    @property\n    def workflow_input(self) -&gt; MyInput:\n        return self._workflow_input\n\n    def _logic(self) -&gt; None:\n        for i in range(self.workflow_input.repeat):\n            self._logger.info(f\"{i+1}: {self.workflow_input.message}\")\n</code></pre>"},{"location":"concepts/#node-to-node-communication","title":"Node-to-Node Communication","text":"<p>Nodes communicate via typed execution classes, either by: - Importing and referencing the upstream node instance after it ran - Using a conditional edge that checks upstream <code>last_execution</code></p> <p>Each node typically lives in its own file; import node classes and create instances in the workflow.</p> <p>producer.py</p> <pre><code>from fluxcli.node import Node, NodeExecution, NodeOutput\n\nclass ProducerOutput(NodeOutput):\n    value: int | None = None\n\nclass ProducerExecution(NodeExecution):\n    output: ProducerOutput = ProducerOutput()\n\nclass Producer(Node):\n    def _create_execution(self) -&gt; ProducerExecution:\n        return ProducerExecution()\n\n    def _logic(self) -&gt; None:\n        self.current_execution.output.value = 42\n</code></pre> <p>consumer.py</p> <pre><code>from fluxcli.node import Node\n\nfrom producer import Producer\n\nclass Consumer(Node):\n    producer: Producer\n\n    def _logic(self) -&gt; None:\n        value = self.producer.last_execution.output.value\n        self._logger.info(value)\n</code></pre> <p>workflow.py</p> <pre><code>from fluxcli.workflow import Workflow\n\nfrom producer import Producer\nfrom consumer import Consumer\n\nwf = Workflow(name=\"demo\")\nproducer = Producer(name=\"producer\")\nconsumer = Consumer(name=\"consumer\", producer=producer)\n\nwf.add_node(producer)\nwf.add_node(consumer)\nwf.add_edge(producer, consumer)\n</code></pre> <p>Conditional edge based on upstream status</p> <pre><code>from fluxcli.workflow import Workflow\nfrom fluxcli.status import StatusCodes\n\nwf = Workflow(name=\"demo\")\nproducer = Producer(name=\"producer\")\nconsumer = Consumer(name=\"consumer\")\n\nwf.add_node(producer)\nwf.add_node(consumer)\n\n# Run consumer only if producer completed successfully and produced a value\nwf.add_conditional_edge(\n    producer,\n    consumer,\n    condition=lambda: (\n        producer.last_execution.status == StatusCodes.COMPLETED\n        and producer.last_execution.output.value is not None\n    ),\n)\n</code></pre>"},{"location":"concepts/#execution-groups","title":"Execution Groups","text":"<p>Execution groups define sets of nodes, where the workflow is considered successful if at least one group succeeds.  </p> <p>Even after a group succeeds, the workflow continues running until no new runnable nodes remain (i.e., all reachable dependencies are exhausted).</p> <p>Execution Groups</p> <ul> <li>Default: all nodes belong to a single group.  </li> <li>Any group\u2019s success marks the workflow as successful.  </li> <li>Execution continues until all reachable nodes are finished.  </li> <li>Enables partial success tolerance for fault-tolerant workflows.</li> </ul> <p>Execution Group Example</p> <pre><code>workflow.add_execution_group([node_a, node_b])\nworkflow.add_execution_group([node_c])\n</code></pre>"},{"location":"concepts/#edges-and-conditional-edges","title":"Edges and Conditional Edges","text":"<p>Edges define dependencies between nodes. Conditional edges execute only if the condition function evaluates True, which can check the last execution status of a node.</p> <p>Edges Example</p> <pre><code>workflow.add_edge(node_a, node_b)  # node_b runs after node_a\nworkflow.add_conditional_edge(\n    node_b,\n    node_c,\n    condition=lambda: node_b.last_execution.status == StatusCodes.COMPLETED\n)\n</code></pre> <p>Edge that runs only if source completed</p> <pre><code>workflow.add_edge_if_source_completed(node_a, node_b)\n</code></pre>"},{"location":"concepts/#wrapping-extensibility","title":"Wrapping &amp; Extensibility","text":"<p>Workflows and nodes can be wrapped or subclassed to add:</p> <ul> <li>Logging and metrics</li> <li>Policy enforcement</li> <li>Integrations with external services</li> <li>Retry or error-handling strategies</li> </ul> <p>Extensibility Example</p> <pre><code>class LoggingNode(PrintNode):\n    def on_start(self) -&gt; None:\n        self._logger.info(f\"Starting {self.name}\")\n\n    def on_success(self) -&gt; None:\n        self._logger.info(f\"Finished {self.name}\")\n\n    def on_failure(self, error) -&gt; None:\n        self._logger.info(f\"{self.name} failed: {error}\")\n</code></pre> <p>This enables consistent cross-cutting behavior without modifying core business logic.</p>"},{"location":"concepts/#lifecycle-hooks","title":"Lifecycle Hooks","text":"<p>FluxCLI nodes provide lifecycle hooks that let you add custom behavior at key points of execution without modifying <code>_logic()</code>.  </p> <p>Available Hooks</p> <ul> <li><code>on_start</code> \u2013 called before <code>_logic()</code> runs.</li> <li><code>on_success</code> \u2013 called after <code>_logic()</code> completes successfully.</li> <li><code>on_failure</code> \u2013 called if <code>_logic()</code> raises an exception.</li> <li><code>on_finish</code> \u2013 always called at the end of execution.</li> </ul> <p>Hooks Example</p> <pre><code>from fluxcli.node import Node\n\nfrom my_input import MyInput\n\nclass LoggingNode(Node):\n    @property\n    def workflow_input(self) -&gt; MyInput:\n        return self._workflow_input\n\n    def _logic(self) -&gt; None:\n        self._logger.info(f\"Running logic for {self.name}\")\n\n    def on_start(self) -&gt; None:\n        self._logger.info(f\"Starting node: {self.name}\")\n\n    def on_success(self) -&gt; None:\n        self._logger.info(f\"Node succeeded: {self.name}\")\n\n    def on_failure(self, error) -&gt; None:\n        self._logger.info(f\"Node failed: {self.name} with error {error}\")\n\n    def on_finish(self) -&gt; None:\n        self._logger.info(f\"Finished execution for node: {self.name}\")\n</code></pre>"},{"location":"concepts/#nodeexecution-workflowexecution","title":"NodeExecution &amp; WorkflowExecution","text":"<p>FluxCLI allows you to customize the execution structure by overriding how executions, outputs, and metadata are created. This lets you inject custom behavior, logging, or extended data without modifying the core node logic.</p> <p>Default Execution Structure:</p> <ul> <li>NodeExecution wraps:</li> <li><code>metadata</code> \u2192 <code>NodeMetadata</code> (start/end times, computed duration)</li> <li><code>status</code> \u2192 <code>StatusCodes</code> (WAITING, IN_PROGRESS, COMPLETED, FAILED)</li> <li><code>output</code> \u2192 <code>NodeOutput</code> (data produced by <code>_logic()</code>)</li> <li> <p><code>error</code> \u2192 <code>NodeError</code> (if the execution fails)</p> </li> <li> <p>WorkflowExecution aggregates:</p> </li> <li><code>metadata</code> \u2192 <code>WorkflowMetadata</code> (workflow start/end times, execution summary)</li> <li><code>output</code> \u2192 Workflow-level output dictionary</li> <li>Status derived from node executions and execution groups</li> </ul> <p>Custom Execution</p> <p>By overriding <code>_create_execution()</code> on a Node, you can use a custom subclass of <code>NodeExecution</code> that stores extra info (e.g., logs, intermediate metrics).</p> <p>Example:</p> <p>custom_execution.py</p> <pre><code>from pydantic import BaseModel\nfrom fluxcli.node import NodeExecution, NodeMetadata\n\n# Custom output for this node\nclass CustomNodeOutput(BaseModel):\n    result_text: str | None = None\n\n# Custom execution with typed metadata and output\nclass CustomNodeExecution(NodeExecution):\n    metadata: NodeMetadata = NodeMetadata()\n    output: CustomNodeOutput = CustomNodeOutput()\n</code></pre> <p>Using Custom Execution:</p> <p>custom_node.py</p> <pre><code>from fluxcli.node import Node\n\nimport CustomNodeExecution, CustomNodeOutput\n\nclass CustomNode(Node):\n    @property\n    def current_execution(self) -&gt; CustomNodeExecution:\n        return super().current_execution\n\n    @property\n    def last_execution(self) -&gt; CustomNodeExecution:\n        return super().last_execution\n\n    def _create_execution(self) -&gt; CustomNodeExecution:\n        return CustomNodeExecution()\n\n    def _logic(self) -&gt; None:\n        self.current_execution.output.result_text = f\"processed{suffix}\"\n        self._logger.info(f\"CustomNode produced: {self.current_execution.output.result_text}\")\n</code></pre> <p>Benefits of Custom Execution &amp; Metadata</p> <ul> <li><code>metadata.start_time</code> and <code>metadata.end_time</code> are tracked automatically.</li> <li>Output fields are fully typed for IDE and type-checker support.</li> <li>Custom execution enables per-node outputs and richer metadata.</li> <li>Facilitates advanced workflows with typed inspection and logging.</li> </ul>"},{"location":"demo/","title":"Demo","text":"<p>FluwCLI includes a structured demo showcasing how to register and run workflows through the CLI.</p> <p>Entry Point</p> <p>Located at: <code>examples/structured_demo/cli/app.py</code></p> <p>You can run the demo command directly from the terminal:</p> <p>Code</p> <pre><code>python examples/structured_demo/cli/app.py structured-demo [--flags]\n</code></pre> <p>This example demonstrates how workflows, nodes, and inputs integrate under the framework.</p>"},{"location":"exceptions/","title":"Exceptions","text":"<p>FluxCLI provides typed exceptions to give precise exit-code and status control. Raise these inside nodes (or workflows) to set both runtime status and process exit code consistently.</p>"},{"location":"exceptions/#built-in-exceptions","title":"Built-in Exceptions","text":"Exception Status Code <code>TimeoutException</code> <code>StatusCodes.TIMED_OUT</code> <code>InfrastructureErrorException</code> <code>StatusCodes.INFRASTRUCTURE_ERROR</code> <code>DataErrorException</code> <code>StatusCodes.DATA_ERROR</code> <code>PrerequisiteFailureException</code> <code>StatusCodes.PREREQUISITE_FAIL</code> <code>APICallFailureException</code> <code>StatusCodes.API_CALL_FAILURE</code> <code>NetworkFailureException</code> <code>StatusCodes.NETWORK_FAILURE</code> <code>DataValidationFailureException</code> <code>StatusCodes.DATA_VALIDATION_FAILURE</code> <code>DependencyUnavailableException</code> <code>StatusCodes.DEPENDENCY_UNAVAILABLE</code>"},{"location":"exceptions/#usage-inside-a-node","title":"Usage Inside a Node","text":"<p>Node Exception Example</p> <pre><code>from fluxcli.node import Node\nfrom fluxcli.exceptions import DataValidationFailureException\n\nclass Validate(Node):\n    def _is_valid_input(self) -&gt; bool:\n        return False\n\n    def _logic(self) -&gt; None:\n        if not self._is_valid_input():\n            raise DataValidationFailureException(\"Invalid input payload\")\n</code></pre>"},{"location":"exceptions/#custom-exceptions","title":"Custom Exceptions","text":"<p>You can define custom exceptions by subclassing <code>WorkflowException</code>. Make sure to set an exit code using a <code>StatusCodes</code> Enum value.</p> <p>Custom Exception Example</p> <pre><code>from enum import Enum\n\nfrom fluxcli.exceptions import WorkflowException\nfrom fluxcli.status import StatusCodes\n\nclass BusinessRuleViolation(WorkflowException):\n    exit_code: Enum = StatusCodes.DATA_ERROR\n</code></pre> <p>Rules for Custom Exceptions</p> <ul> <li>Exit codes must be validated integers (0\u2013255).  </li> <li>Raising a <code>WorkflowException</code> marks the current node attempt with that status.  </li> <li>Workflow execution propagates the consistent status and exit code downstream.</li> </ul>"},{"location":"features/","title":"Features","text":"<p>FluxCLI is a CLI-first framework for designing, running, and shipping DAG-based workflows with strong typing, lifecycle hooks, and maintainable code structure. It\u2019s built for developers who want predictable, debuggable, and production-ready workflows.</p>"},{"location":"features/#cli-first-strongly-typed","title":"CLI-first, strongly typed","text":"<p>Each workflow becomes a CLI command. Flags are auto-generated from your <code>WorkflowInput</code> types, including type hints, defaults, and descriptions. This eliminates manual parsing and ensures consistent interfaces across scripts and production pipelines.</p> <p>CLI Example</p> <pre><code>from fluxcli import FluxCLI\nfrom fluxcli.workflow import Workflow, WorkflowInput\nfrom fluxcli.node import Node\n\nclass MyInput(WorkflowInput):\n    message: str = \"hello\"\n\nclass Echo(Node):\n    @property\n    def workflow_input(self) -&gt; MyInput:\n        return self._workflow_input\n\n    def _logic(self) -&gt; None:\n        self._logger.info(f\"Message: {self.workflow_input.message}\")\n\ncli = FluxCLI()\ncli.add_command(\"echo-msg\", lambda: Workflow(\"echo-demo\"), MyInput)\ncli.run()\n</code></pre>"},{"location":"features/#modern-python-throughout","title":"Modern Python throughout","text":"<p>Workflows and nodes are implemented using idiomatic Python classes and type annotations. No DSLs or YAML schemas are required\u2014use Pydantic for input validation and serialization.</p> <p>Type-safe Node Example</p> <pre><code>class CounterInput(WorkflowInput):\n    count: int = 5\n\nclass Counter(Node):\n    @property\n    def workflow_input(self) -&gt; CounterInput:\n        return self._workflow_input\n\n    def _logic(self) -&gt; None:\n        for i in range(self.workflow_input.count):\n            self._logger.info(f\"Step {i+1}\")\n</code></pre>"},{"location":"features/#node-to-node-communication","title":"Node-to-node communication","text":"<p>Nodes communicate via typed execution classes, either by: - Importing and referencing the upstream node instance after it ran - Using a conditional edge that checks upstream <code>last_execution</code></p> <p>Each node typically lives in its own file; import node classes and create instances in the workflow.</p> <p>producer.py</p> <pre><code>from fluxcli.node import Node, NodeExecution, NodeOutput\n\nclass ProducerOutput(NodeOutput):\n    value: int | None = None\n\nclass ProducerExecution(NodeExecution):\n    output: ProducerOutput = ProducerOutput()\n\nclass Producer(Node):\n    def _create_execution(self) -&gt; ProducerExecution:\n        return ProducerExecution()\n\n    def _logic(self) -&gt; None:\n        self.current_execution.output.value = 42\n</code></pre> <p>consumer.py</p> <pre><code>from fluxcli.node import Node\n\nfrom producer import Producer\n\nclass Consumer(Node):\n    producer: Producer\n\n    def _logic(self) -&gt; None:\n        value = self.producer.last_execution.output.value\n        self._logger.info(value)\n</code></pre> <p>workflow.py</p> <pre><code>from fluxcli.workflow import Workflow\n\nfrom producer import Producer\nfrom consumer import Consumer\n\nwf = Workflow(name=\"demo\")\nproducer = Producer(name=\"producer\")\nconsumer = Consumer(name=\"consumer\", producer=producer)\n\nwf.add_node(producer)\nwf.add_node(consumer)\nwf.add_edge(producer, consumer)\n</code></pre> <p>Edge that runs only if source completed</p> <pre><code>wf.add_edge_if_source_completed(producer, consumer)\n</code></pre> <p>Conditional edge based on upstream status</p> <pre><code>from fluxcli.workflow import Workflow\nfrom fluxcli.status import StatusCodes\n\nwf = Workflow(name=\"demo\")\nproducer = Producer(name=\"producer\")\nconsumer = Consumer(name=\"consumer\")\n\nwf.add_node(producer)\nwf.add_node(consumer)\n\n# Run consumer only if producer completed successfully and produced a value\nwf.add_conditional_edge(\n    producer,\n    consumer,\n    condition=lambda: (\n        producer.last_execution.status == StatusCodes.COMPLETED\n        and producer.last_execution.output.value is not None\n    ),\n)\n</code></pre>"},{"location":"features/#dag-orchestration-with-validation-and-retries","title":"DAG orchestration with validation and retries","text":"<p>Workflows are automatically validated as DAGs. Execution respects dependencies and conditional edges.</p> <p>DAG Example</p> <pre><code>wf = Workflow(\"demo\")\n\nnode_a = Echo(name=\"A\", timeout_seconds=5)\nnode_b = Echo(name=\"B\")\nnode_c = Echo(name=\"C\")\n\nwf.add_node(node_a)\nwf.add_node(node_b)\nwf.add_node(node_c)\n\nwf.add_edge(node_a, node_b)  # B runs after A\nwf.add_conditional_edge(node_b, node_c, condition=lambda: True)\n</code></pre>"},{"location":"features/#lifecycle-hooks","title":"Lifecycle hooks","text":"<p>Add cross-cutting behavior without touching business logic. Hooks exist at both node and workflow levels:</p> <ul> <li><code>on_start</code> \u2013 before execution  </li> <li><code>on_success</code> \u2013 after success  </li> <li><code>on_failure</code> \u2013 after failure  </li> <li><code>on_finish</code> \u2013 always called</li> </ul> <p>Logging Example</p> <pre><code>class Echo(Node):\n    def on_start(self) -&gt; None:\n        self._logger.info(f\"Starting {self.name}\")\n\n    def on_success(self) -&gt; None:\n        self._logger.info(f\"Finished {self.name}\")\n</code></pre>"},{"location":"features/#typed-exceptions-and-consistent-exit-codes","title":"Typed exceptions and consistent exit codes","text":"<ul> <li>Raise custom exceptions mapped to <code>StatusCodes</code>.</li> <li>CLI and schedulers always receive consistent exit codes.</li> <li>Makes CI/CD pipelines predictable.</li> </ul> <p>Exception Example</p> <pre><code>from fluxcli.exceptions import WorkflowException\nfrom fluxcli.status import StatusCodes\n\nclass MyNode(Node):\n    def _logic(self) -&gt; None:\n        raise WorkflowException(\"Something went wrong\", exit_code=StatusCodes.FAILURE)\n</code></pre>"},{"location":"features/#auto-generated-documentation-and-diagrams","title":"Auto-generated documentation and diagrams","text":"<p>FluxCLI can generate Markdown documentation and DAG diagrams automatically. Helps teams review workflow structures and share knowledge.</p> <p>Simple workflow</p> <p> Clear, linear steps for quick tasks.</p> <p>Complex workflow</p> <p> Branching, conditional edges, and parallel paths.</p>"},{"location":"features/#extensible-architecture","title":"Extensible architecture","text":"<ul> <li>Wrap workflows and nodes to add logging, metrics, policies, integrations.</li> <li>Define a base layer for shared defaults and configuration.</li> <li>Scale from local scripts to production pipelines with minimal rewrites.</li> </ul>"},{"location":"features/#tested-and-type-checked","title":"Tested and type-checked","text":"<ul> <li>Unit tests cover workflow behavior.</li> <li>Continuous integration enforces linting, type-checks, and formatting.</li> <li>Strong typing ensures safe refactors and long-term maintainability.</li> </ul>"},{"location":"getting-started/","title":"Getting Started with FluxCLI","text":"<p>FluxCLI lets you quickly design, run, and manage DAG-based workflows using Python and CLI commands. This guide walks you through creating your first workflow, adding nodes, handling inputs, and executing it via the CLI.</p>"},{"location":"getting-started/#1-install-fluxcli","title":"1. Install FluxCLI","text":"<p>Install via pip:</p> <p>Install via pip</p> <pre><code>pip install fluxcli\n</code></pre> <p>Or clone the repository for development:</p> <p>Clone for development</p> <pre><code>git clone https://github.com/your-repo/fluxcli.git\ncd fluxcli\npip install -e .\n</code></pre>"},{"location":"getting-started/#2-define-a-workflow-input","title":"2. Define a Workflow Input","text":"<p>Workflows use typed inputs with Pydantic for validation. Annotate fields with descriptions and constraints to improve CLI help and validation.</p> <p>Workflow Input Example (with descriptions and validations)</p> <pre><code>from typing import Annotated\n\nfrom pydantic import Field\nfrom fluxcli.workflow import WorkflowInput\n\nclass MyWorkflowInput(WorkflowInput):\n    message: Annotated[str, Field(min_length=1, max_length=100, description=\"Message to print\")]\n        = \"Hello, FluxCLI!\"\n    repeat: Annotated[int, Field(ge=1, le=10, description=\"How many times to repeat\")]\n        = 3\n</code></pre>"},{"location":"getting-started/#3-create-nodes","title":"3. Create Nodes","text":"<p>Nodes encapsulate single units of work. Each node receives the workflow input and communicates results via typed outputs, avoiding ad-hoc dictionaries or positional references.</p> <p>Node Example</p> <pre><code>from fluxcli.node import Node\n\nclass PrintNode(Node):\n    @property\n    def workflow_input(self) -&gt; MyWorkflowInput:\n        return self._workflow_input\n\n    def _logic(self) -&gt; None:\n        for i in range(self.workflow_input.repeat):\n            self._logger.info(f\"{i+1}: {self.workflow_input.message}\")\n</code></pre>"},{"location":"getting-started/#4-assemble-a-workflow","title":"4. Assemble a Workflow","text":"<p>Create a workflow, add nodes, and define their dependencies.</p> <p>Assemble Workflow</p> <pre><code>from fluxcli.workflow import Workflow\n\nworkflow = Workflow(name=\"demo-workflow\")\n\n# Nodes\nnode_a = PrintNode(name=\"PrintMessage\")\n\n# Add nodes\nworkflow.add_node(node_a)\n\n# Optionally, add edges if multiple nodes exist\n# workflow.add_edge(node_a, node_b)\n# workflow.add_edge_if_source_completed(node_a, node_b)  # run node_b only if node_a completed\n</code></pre>"},{"location":"getting-started/#5-execute-the-workflow-via-cli","title":"5. Execute the Workflow via CLI","text":"<p>FluxCLI automatically generates CLI commands based on your workflow and input class.</p> <p>CLI Execution</p> <pre><code>from fluxcli import FluxCLI\n\ncli = FluxCLI()\ncli.add_command(\"run-demo\", lambda: workflow, MyWorkflowInput)\ncli.run()\n</code></pre> <p>Run from terminal:</p> <p>Run from terminal</p> <pre><code>python your_script.py run-demo --message \"Hi there!\" --repeat 5\n</code></pre>"},{"location":"getting-started/#6-handle-lifecycle-hooks","title":"6. Handle Lifecycle Hooks","text":"<p>Extend nodes with hooks for logging, metrics, cleanup, or notifications. Hooks exist for both nodes and workflows:</p> <ul> <li><code>on_start</code> \u2013 before execution  </li> <li><code>on_success</code> \u2013 after successful completion  </li> <li><code>on_failure</code> \u2013 after failure  </li> <li><code>on_finish</code> \u2013 always called</li> </ul> <p>Lifecycle Hooks Example</p> <pre><code>class LoggingNode(PrintNode):\n    def on_start(self) -&gt; None:\n        self._logger.info(f\"Starting node: {self.name}\")\n\n    def on_success(self) -&gt; None:\n        self._logger.info(f\"Finished node: {self.name}\")\n\n    def on_failure(self, error) -&gt; None:\n        self._logger.info(f\"Node {self.name} failed: {error}\")\n</code></pre>"},{"location":"getting-started/#7-enable-auto-generated-documentation","title":"7. Enable Auto-Generated Documentation","text":"<p>FluxCLI can automatically generate Markdown documentation and DAG diagrams. Configure it either:</p> <ul> <li>Programmatically: set defaults in <code>workflow.inputs</code>.</li> <li>Via CLI flags: pass at runtime; flags map to <code>WorkflowInput</code> fields.</li> </ul> <p>Programmatic defaults (set once)</p> <pre><code># Set default documentation behavior on the workflow template\nworkflow.inputs = MyWorkflowInput(\n    auto_generate_md=True,\n    md_file_path=\"workflow_doc.md\",\n    diagram_file_path=\"workflow_diagram.png\",\n)\n</code></pre> <p>Via CLI flags (override defaults)</p> <pre><code>python your_script.py run-demo \\\n  --auto-generate-md \\\n  --md-file-path workflow_doc.md \\\n  --diagram-file-path workflow_diagram.png\n</code></pre> <p>Note</p> <p>At the end of execution, FluxCLI outputs a readable summary and a diagram of the workflow. Useful for reviews, knowledge sharing, and onboarding new developers.</p>"},{"location":"getting-started/#8-next-steps","title":"8. Next Steps","text":"<ul> <li>Add conditional edges and parallel execution groups.</li> <li>Explore typed exceptions for reliable error handling.</li> <li>Integrate with logging, metrics, or CI/CD pipelines.</li> <li>Write unit tests for workflows and nodes to ensure predictable behavior.</li> </ul> <p>Note</p> <p>Once you are comfortable with the basics, you can start building production-ready pipelines using FluxCLI, scaling from local scripts to distributed workflows.</p>"},{"location":"people/","title":"Maintainers","text":"<ul> <li>Shahar Band \u2014 creator and maintainer</li> </ul> <p>Contributions are welcome via pull requests on the repository.</p>"},{"location":"resources/","title":"Resources","text":"<p>More about FluxCLI:</p> <ul> <li>Repository: GitHub </li> <li>PyPI: fluxcli </li> <li>Report Issues: GitHub Issues </li> </ul> <p>Article Coming Soon</p> <p>A detailed article explaining FluxCLI concepts and usage will be published shortly.</p>"}]}